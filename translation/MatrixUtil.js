"use strict";var MatrixUtil;(function (MatrixUtil) {    class Matrix {        constructor(rowCount, columnCount) {            this.rowCount = rowCount;            this.columnCount = columnCount;            this.rowVec = new Array(this.rowCount);            for (let i = 0; (i < this.rowCount); ++i) {                this.rowVec[i] = new Array(this.columnCount);            }        }        MultiplyScalar(val) {            let r = new Matrix(this.rowCount, this.columnCount);            for (let i = 0; i < this.rowCount; ++i) {                let thisRow = this.rowVec[i];                let otherRow = r.rowVec[i];                for (let j = 0; j < this.columnCount; ++j) {                    otherRow[j] = thisRow[j] * val;                }            }            return r;        }        PartialAdd(centerRow, centerCol, other) {            PackedMatrix.RangeCheck(centerRow, this.rowCount);            PackedMatrix.RangeCheck(centerCol, this.columnCount);            let width = other.columnCount;            let height = other.rowCount;            let [startRow, lastRow, otherRowStart] = PackedMatrix.GetRange(centerRow, height, this.rowCount);            let [startCol, lastCol, otherColStart] = PackedMatrix.GetRange(centerCol, width, this.columnCount);            for (let i = startRow, k = otherRowStart; i < lastRow; ++k, ++i) {                let thisRow = this.rowVec[i];                let otherRow = other.rowVec[k];                for (let j = startCol, l = otherColStart; j < lastCol; ++l, ++j) {                    thisRow[j] += otherRow[l];                }            }        }        DivideBy(other) {            if (((this.rowCount != other.rowCount)                || (this.columnCount != other.columnCount))) {                throw new Error("size not match!");            }            for (let i = 0; (i < this.rowCount); i++) {                let thisRow = this.rowVec[i];                let otherRow = other.rowVec[i];                for (let j = 0; (j < this.columnCount); j++) {                    // test other.rowVec[i, j] == 0                    thisRow[j] = Math.abs(otherRow[j]) < 1E-45 ? 1 : thisRow[j] / otherRow[j];                }            }        }    }    MatrixUtil.Matrix = Matrix;    class PackedMatrix {        constructor(rowCount, columnCount) {            this.rowCount = rowCount;            this.columnCount = columnCount;            this.linearData = new Array((this.rowCount * this.columnCount));        }        static RangeCheck(val, maxExclusive) {            if (((val < 0) || (val >= maxExclusive))) {                throw new Error("out of range");            }        }        static GetRange(center, len, max) {            let half = (len / 2);            let otherStart = (center - half);            let otherEnd = (otherStart + len);            let start = otherStart < 0 ? 0 : otherStart;            otherStart = (start - otherStart);            let end = otherEnd > max ? max : otherEnd;            return [start, end, otherStart];        }        MultiplyScalar(val) {            let r = new PackedMatrix(this.rowCount, this.columnCount);            for (let i = 0, len = this.linearData.length; (i < len); i++) {                r.linearData[i] = (this.linearData[i] * val);            }            return r;        }        PartialAdd(centerRow, centerCol, other) {            PackedMatrix.RangeCheck(centerRow, this.rowCount);            PackedMatrix.RangeCheck(centerCol, this.columnCount);            let width = other.columnCount;            let height = other.rowCount;            let [startRow, lastRow, otherRowStart] = PackedMatrix.GetRange(centerRow, height, this.rowCount);            let [startCol, lastCol, otherColStart] = PackedMatrix.GetRange(centerCol, width, this.columnCount);            for (let i = startRow * this.columnCount + startCol, len = lastRow * this.columnCount + startCol, k = otherRowStart * width + otherColStart, delta = lastCol - startCol; i < len; i += this.columnCount, k += width) {                for (let j = i, updateLen = i + delta, l = k; j < updateLen; ++j, ++l) {                    this.linearData[j] += other.linearData[l];                }            }        }        DivideBy(other) {            if (((this.rowCount != other.rowCount)                || (this.columnCount != other.columnCount))) {                throw new Error("size not match!");            }            for (let i = 0, len = this.linearData.length; i < len; i++) {                //test other.linearData[i] == 0                this.linearData[i] = Math.abs(other.linearData[i]) < 1E-45 ? 1 : this.linearData[i] / other.linearData[i];            }        }    }    MatrixUtil.PackedMatrix = PackedMatrix;})(MatrixUtil || (MatrixUtil = {}));